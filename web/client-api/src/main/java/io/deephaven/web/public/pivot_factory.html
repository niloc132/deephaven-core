<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Pivot Factory example page</title>
    <link href="basic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="pivot"></div>
<script type="module">
    // This example assumes that the pivot factory has been added to the scope as "factory".

    import dh from './dh-core.js'
    const {CoreClient, Table, Widget} = dh;
    var connection;
    (async () => {
        var client = new CoreClient('http://localhost:10000');
        await client.login({type:CoreClient.LOGIN_TYPE_ANONYMOUS});
        connection = await client.getAsIdeConnection();

        var types = await connection.getConsoleTypes();

        // In the currently running language, create a ticking table with some sample data - one column will grow, the others
        // will be bounded to avoid getting so much data we can't easily see it in the window.
        if (types.indexOf("python") !== -1) {
            var ide = await connection.startSession("python");
            await ide.runCode(`
from deephaven import time_table
remoteTable = time_table("PT1s").update_view(["I=i", "J=(811 * I) % 17", "K=(821 * I) % 19"])
`);
        } else if (types.indexOf("groovy") !== -1) {
            var ide = await connection.startSession("groovy");
            await ide.runCode('remoteTable = timeTable("PT1s").updateView("I=i", "J=(811 * I) % 17", "K=(821 * I) % 19")');
        }
        var remoteTable = await connection.getObject({name:"remoteTable", type:"table"});

        // Fetch the pivot factory object
        var factory = await connection.getObject({name:"factory", type:"simplepivot.SimplePivotTable.Factory"});

        // Add a listener before we request a pivot be created
        factory.addEventListener(Widget.EVENT_MESSAGE, async e => {
            var response = JSON.parse(e.detail.getDataAsString());
            if (response.error) {
                console.error(e.error);
                return;
            }
            showPivot(await e.detail.exportedObjects[0].fetch());
        });

        // Create a pivot widget with the factory, response is sent to the listener above
        factory.sendMessage(JSON.stringify({
            rowColNames: ["J"],
            columnColNames: ["K"],
            valueColName: "I",
            aggregation: 'AVG',
            hasTotals: true
        }), [remoteTable]);
    })();

    var pivotElt = document.getElementById('pivot');
    var PAGE_SIZE = 20;
    var schema;
    var columnMap = new Map();

    function showPivot(pivotWidget) {
        schema = JSON.parse(pivotWidget.getDataAsString());

        // The initial state is our keys to use for column headers
        var loaded = pivotWidget.exportedObjects[0].fetch().then(loadKeys);

        // Add a listener for each pivot schema change, so we get the first update, with the table to render.
        // Note that there is no await between this line and the pivotWidget being returned, or we would miss the first update
        pivotWidget.addEventListener(Widget.EVENT_MESSAGE, async e => {
            // Get the object, and make sure the keytable is fetched and usable
            var tables = e.detail.exportedObjects;
            var tableToRenderPromise = tables[0].fetch();
            var totalsPromise;
            if (tables.length == 2) {
                totalsPromise = tables[1].fetch();
            } else {
                totalsPromise = Promise.resolve(null);
            }
            // Wait for all three promises to have resolved, then render the table. Note that after
            // the first load, the keytable will remain loaded, we'll only wait for the main table,
            // and optionally the totals table.
            var tableToRender = await Promise.all([loaded, tableToRenderPromise, totalsPromise]).then(a => [a[1], a[2]]);
            showChangedPivotSchema(tableToRender);
        });
    }

    function loadKeys(keyTable) {
        return new Promise((resolve, reject) => {
            var pivotIdColumn = keyTable.findColumn('__PIVOT_COLUMN')
            var columns = keyTable.columns.filter(c => c.name !== '__PIVOT_COLUMN');
            var subscription = keyTable.subscribe(keyTable.columns);
            subscription.addEventListener(Table.EVENT_UPDATED, e => {
                var data = e.detail;
                var rowIter = data.fullIndex.iterator();
                while (rowIter.hasNext()) {
                    var rowKey = rowIter.next().value;
                    var value = [];
                    for (const c of columns) {
                        value.push(data.getData(rowKey, c));
                    }

                    columnMap.set("PIVOT_C_" + data.getData(rowKey, pivotIdColumn), value.join(","));
                }
                console.log(columnMap);
                resolve();
            });
        });
    }
    var table, totalsTable;
    var oldTableHandlerCleanup, oldTotalsHandlerCleanup;
    var currentOffset;
    function showChangedPivotSchema(tables) {

        // correctly disconnect from the old table, if any
        oldTableHandlerCleanup && oldTableHandlerCleanup();
        oldTotalsHandlerCleanup && oldTotalsHandlerCleanup();
        table && table.close();
        totalsTable && totalsTable.close();
        table = tables[0];
        totalsTable = tables[1];

        currentOffset = 0;
        //build a simple table in the dom after removing the old one
        while (pivotElt.hasChildNodes()) {
            pivotElt.removeChild(pivotElt.lastChild);
        }
        var header = document.createElement('thead');
        var headerRow = document.createElement('tr');
        // First write rows group col names
        schema.rowColNames.forEach(colName => {
            var td = document.createElement('td');
            td.innerText = colName;
            headerRow.appendChild(td);
        });
        // Then go over the currently known column groups
        for (let [realColName, value] of columnMap) {
            var td = document.createElement('td');
            td.innerText = value;
            headerRow.appendChild(td);
        }
        // Optionally append a totals column
        if (schema.hasTotals) {
            var td = document.createElement('td');
            td.innerText = "Totals";
            headerRow.appendChild(td);
        }

        header.appendChild(headerRow);
        pivotElt.appendChild(header);
        var body = document.createElement('tbody');
        body.className = 'body';
        pivotElt.appendChild(body);
        var foot = document.createElement('tbody');
        foot.className = 'foot';
        pivotElt.appendChild(foot);

        // listen for items to be added, populate the table body
        oldTableHandlerCleanup = table.addEventListener(Table.EVENT_UPDATED, function (event) {
            console.log("update event received");
            // rebuild the current tbody from scratch
            while (body.hasChildNodes()) {
                body.removeChild(body.lastChild);
            }

            var viewportData = event.detail;
            var rows = viewportData.rows;
            for (var i = 0; i < rows.length; i++) {
                var tr = document.createElement('tr');
                // Iterate columns in the same order as the header - row groups first
                schema.rowColNames.forEach(colName => {
                    var col = table.findColumn(colName);
                    var td = document.createElement('td');
                    td.textContent = rows[i].get(col);
                    var format = rows[i].getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    tr.appendChild(td);
                });
                // Then go over the currently known column groups
                for (let [realColName, value] of columnMap) {
                    try {
                        var col = table.findColumn(realColName);
                    } catch (e) {
                        // If the column is not found, just skip it (key table update arrived first)
                        continue;
                    }
                    var td = document.createElement('td');
                    td.textContent = rows[i].get(col);
                    var format = rows[i].getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    tr.appendChild(td);
                }
                // Last, optionally append a totals column
                if (schema.hasTotals) {
                    var td = document.createElement('td');
                    var totalsCol = table.findColumn('__TOTALS_COLUMN');
                    td.textContent = rows[i].get(totalsCol);
                    var format = rows[i].getFormat(totalsCol);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    td.style.fontWeight = 'bold';
                    tr.appendChild(td);
                }
                body.appendChild(tr);
            }
        });

        if (totalsTable) {
            oldTotalsHandlerCleanup = totalsTable.addEventListener(Table.EVENT_UPDATED, function (event) {
                console.log('totals table update received');
                // rebuild the current tbody from scratch
                while (foot.hasChildNodes()) {
                    foot.removeChild(foot.lastChild);
                }
                var viewportData = event.detail;
                if (viewportData.rows.length === 0) {
                    return;
                }
                var row = viewportData.rows[0];

                var tr = document.createElement('tr');

                // Iterate through the row groups, write an empty placeholder
                schema.rowColNames.forEach(colName => {
                    tr.appendChild(document.createElement('td'));
                });
                // Next, the column groups, which have a total value in the row
                for (let [realColName, value] of columnMap) {
                    try {
                        var col = totalsTable.findColumn(realColName);
                    } catch (e) {
                        // If the column is not found, just skip it (key table update arrived first)
                        continue;
                    }
                    var td = document.createElement('td');
                    td.textContent = row.get(col);
                    var format = row.getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    td.style.weight = 'bold';
                    tr.appendChild(td);
                }
                // Last, append the cell with the total value of the whole table
                var totalsCol = totalsTable.findColumn('__TOTALS_COLUMN');
                var td = document.createElement('td');
                td.textContent = row.get(totalsCol);
                var format = row.getFormat(totalsCol);
                td.style.backgroundColor = format.backgroundColor;
                td.style.color = format.color;
                td.style.weight = 'bold';
                tr.appendChild(td);

                foot.appendChild(tr);
            });
        }

        // Subscribe to data - could be selective about columns to subscribe to:
        // Load the very first page - could implement paging here
        load();
        // Only one row in totals, subscribe to it
        totalsTable && totalsTable.setViewport(0, 0);
    }
    function load() {
        table.setViewport(currentOffset, currentOffset + PAGE_SIZE - 1);
    }
</script>
</body>
</html>
