<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Pivot example page</title>
    <link href="basic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="pivot"></div>
<script type="module">
    // We start by assuming that some server code has run to create the ticking table, and build the pivot object
    // around it, so that this file doesn't turn into a polyglot mess.

    import dh from './dh-core.js'
    const {CoreClient, Table, Widget} = dh;
    var connection;
    (async () => {
        var client = new CoreClient('http://localhost:10000');
        await client.login({type:CoreClient.LOGIN_TYPE_ANONYMOUS});
        connection = await client.getAsIdeConnection();

        // Ask the server for the object named "ticking_pivot"
        var pivotWidget = await connection.getObject({name:"ticking_pivot", type:"simplepivot.SimplePivotTable"});

        // The initial state is our keys to use for column headers
        var loaded = pivotWidget.exportedObjects[0].fetch().then(loadKeys);

        // Add a listener for each pivot schema change, so we get the first update, with the table to render.
        // Note that there is no await between this line and the pivotWidget being returned, or we would miss the first update
        pivotWidget.addEventListener(Widget.EVENT_MESSAGE, async e => {
            // Get the object, and make sure the keytable is fetched and usable
            var tableToRenderPromise = e.detail.exportedObjects[0].fetch();
            var tableToRender = await Promise.all([loaded, tableToRenderPromise]).then(a => a[1]);
            showChangedPivotSchema(tableToRender);
        });

    })();

    var pivotElt = document.getElementById('pivot');
    var PAGE_SIZE = 20;
    var COLUMN_COUNT = 10;
    var columnMap = new Map();

    function loadKeys(keyTable) {
        return new Promise((resolve, reject) => {
            var pivotIdColumn = keyTable.findColumn('__PIVOT_COLUMN')
            var columns = keyTable.columns.filter(c => c.name !== '__PIVOT_COLUMN');
            var subscription = keyTable.subscribe(keyTable.columns);
            subscription.addEventListener(Table.EVENT_UPDATED, e => {
                var data = e.detail;
                var rowIter = data.fullIndex.iterator();
                while (rowIter.hasNext()) {
                    var rowKey = rowIter.next().value;
                    var value = [];
                    for (const c of columns) {
                        value.push(data.getData(rowKey, c));
                    }

                    columnMap.set("PIVOT_C_" + data.getData(rowKey, pivotIdColumn), value.join(","));
                }
                console.log(columnMap);
                resolve();
            });
        });
    }
    var table;
    var oldTableHandlerCleanup;
    var currentOffset;
    function showChangedPivotSchema(pivot) {

        // correctly disconnect from the old table, if any
        oldTableHandlerCleanup && oldTableHandlerCleanup();
        table && table.close();
        table = pivot;
        currentOffset = 0;
        //build a simple table in the dom after removing the old one
        while (pivotElt.hasChildNodes()) {
            pivotElt.removeChild(pivotElt.lastChild);
        }
        var header = document.createElement('thead');
        var headerRow = document.createElement('tr');
        table.columns.forEach(columnDef => {
            // build a very simple header from premade value headers
            var td = document.createElement('td');
            if (columnDef.name.startsWith("PIVOT_C_")) {
                td.innerText = columnMap.get(columnDef.name);
            } else {
                td.innerText = columnDef.name;
            }

            headerRow.appendChild(td);
        });
        header.appendChild(headerRow);
        pivotElt.appendChild(header);

        // listen for items to be added, populate the table body
        oldTableHandlerCleanup = table.addEventListener(Table.EVENT_UPDATED, function handleTableUpdate(event) {
            console.log("update event received, time to redraw data");
            // rebuild the current tbody from scratch
            var tbody = pivotElt.querySelector('tbody');
            tbody && pivotElt.removeChild(tbody);
            tbody = document.createElement('tbody');

            var viewportData = event.detail;
            var rows = viewportData.rows;
            for (var i = 0; i < rows.length; i++) {
                var tr = document.createElement('tr');
                for (var j = 0; j < table.columns.length; j++) {
                    var td = document.createElement('td');
                    td.textContent = rows[i].get(table.columns[j]);
                    var format = rows[i].getFormat(table.columns[j]);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            pivotElt.appendChild(tbody);
        });

        // load the very first page
        load();
    }
    function load() {
        table.setViewport(currentOffset, currentOffset + PAGE_SIZE - 1);
    }
</script>
</body>
</html>
