<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Pivot example page</title>
    <link href="basic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="pivot"></div>
<script type="module">
    // We start by assuming that some server code has run to create the ticking table, and build the pivot object
    // around it, so that this file doesn't turn into a polyglot mess.

    import dh from './dh-core.js'
    const {CoreClient, Table, Widget} = dh;
    var connection;
    var schema;
    (async () => {
        var client = new CoreClient('http://localhost:10000');
        await client.login({type:CoreClient.LOGIN_TYPE_ANONYMOUS});
        connection = await client.getAsIdeConnection();

        // Ask the server for the object named "ticking_pivot"
        var pivotWidget = await connection.getObject({name:"ticking_pivot", type:"simplepivot.SimplePivotTable"});

        schema = JSON.parse(pivotWidget.getDataAsString());

        // The initial state is our keys to use for column headers
        var loaded = pivotWidget.exportedObjects[0].fetch().then(loadKeys);

        // Add a listener for each pivot schema change, so we get the first update, with the table to render.
        // Note that there is no await between this line and the pivotWidget being returned, or we would miss the first update
        pivotWidget.addEventListener(Widget.EVENT_MESSAGE, async e => {
            // Get the object, and make sure the keytable is fetched and usable
            var tables = e.detail.exportedObjects;
            var tableToRenderPromise = tables[0].fetch();
            var totalsPromise;
            if (tables.length == 2) {
                totalsPromise = tables[1].fetch();
            } else {
                totalsPromise = Promise.resolve(null);
            }
            // Wait for all three promises to have resolved, then render the table. Note that after
            // the first load, the keytable will remain loaded, we'll only wait for the main table,
            // and optionally the totals table.
            var tableToRender = await Promise.all([loaded, tableToRenderPromise, totalsPromise]).then(a => [a[1], a[2]]);
            showChangedPivotSchema(tableToRender);
        });

    })();

    var pivotElt = document.getElementById('pivot');
    var PAGE_SIZE = 20;
    var COLUMN_COUNT = 10;
    var columnMap = [];

    function loadKeys(keyTable) {
        return new Promise((resolve, reject) => {
            var pivotIdColumn = keyTable.findColumn('__PIVOT_COLUMN')
            var columns = keyTable.columns.filter(c => c.name !== '__PIVOT_COLUMN');
            var subscription = keyTable.subscribe(keyTable.columns);
            subscription.addEventListener(Table.EVENT_UPDATED, e => {
                columnMap = [];
                var data = e.detail;
                var rowIter = data.fullIndex.iterator();
                while (rowIter.hasNext()) {
                    var rowKey = rowIter.next().value;
                    var value = [];
                    for (const c of columns) {
                        value.push(data.getData(rowKey, c));
                    }

                    columnMap.push(["PIVOT_C_" + data.getData(rowKey, pivotIdColumn), value.join(",")]);
                }
                resolve();
            });
        });
    }
    var table, totalsTable;
    var oldTableHandlerCleanup, oldTotalsHandlerCleanup;
    var currentOffset;
    function showChangedPivotSchema(tables) {

        // correctly disconnect from the old table, if any
        oldTableHandlerCleanup && oldTableHandlerCleanup();
        oldTotalsHandlerCleanup && oldTotalsHandlerCleanup();
        table && table.close();
        totalsTable && totalsTable.close();
        table = tables[0];
        totalsTable = tables[1];

        currentOffset = 0;
        //build a simple table in the dom after removing the old one
        while (pivotElt.hasChildNodes()) {
            pivotElt.removeChild(pivotElt.lastChild);
        }
        var header = document.createElement('thead');
        var headerRow = document.createElement('tr');
        // First write rows group col names
        schema.rowColNames.forEach(colName => {
            var td = document.createElement('td');
            td.innerText = colName;
            headerRow.appendChild(td);
        });
        // Then go over the currently known column groups
        for (let [realColName, value] of columnMap) {
            var td = document.createElement('td');
            td.innerText = value;
            headerRow.appendChild(td);
        }
        // Optionally append a totals column
        if (schema.hasTotals) {
            var td = document.createElement('td');
            td.innerText = "Totals";
            headerRow.appendChild(td);
        }

        header.appendChild(headerRow);
        pivotElt.appendChild(header);
        var body = document.createElement('tbody');
        body.className = 'body';
        pivotElt.appendChild(body);
        var foot = document.createElement('tbody');
        foot.className = 'foot';
        pivotElt.appendChild(foot);

        // listen for items to be added, populate the table body
        oldTableHandlerCleanup = table.addEventListener(Table.EVENT_UPDATED, function (event) {
            console.log("update event received");
            // rebuild the current tbody from scratch
            while (body.hasChildNodes()) {
                body.removeChild(body.lastChild);
            }

            var viewportData = event.detail;
            var rows = viewportData.rows;
            for (var i = 0; i < rows.length; i++) {
                var tr = document.createElement('tr');
                // Iterate columns in the same order as the header - row groups first
                schema.rowColNames.forEach(colName => {
                    var col = table.findColumn(colName);
                    var td = document.createElement('td');
                    td.textContent = rows[i].get(col);
                    var format = rows[i].getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    tr.appendChild(td);
                });
                // Then go over the currently known column groups
                for (let [realColName, value] of columnMap) {
                    try {
                        var col = table.findColumn(realColName);
                    } catch (e) {
                        // If the column is not found, just skip it (key table update arrived first)
                        continue;
                    }
                    var td = document.createElement('td');
                    td.textContent = rows[i].get(col);
                    var format = rows[i].getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    tr.appendChild(td);
                }
                // Last, optionally append a totals column
                if (schema.hasTotals) {
                    var td = document.createElement('td');
                    var totalsCol = table.findColumn('__TOTALS_COLUMN');
                    td.textContent = rows[i].get(totalsCol);
                    var format = rows[i].getFormat(totalsCol);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    td.style.fontWeight = 'bold';
                    tr.appendChild(td);
                }
                body.appendChild(tr);
            }
        });

        if (totalsTable) {
            oldTotalsHandlerCleanup = totalsTable.addEventListener(Table.EVENT_UPDATED, function (event) {
                console.log('totals table update received');
                // rebuild the current tbody from scratch
                while (foot.hasChildNodes()) {
                    foot.removeChild(foot.lastChild);
                }
                var viewportData = event.detail;
                if (viewportData.rows.length === 0) {
                    return;
                }
                var row = viewportData.rows[0];

                var tr = document.createElement('tr');

                // Iterate through the row groups, write an empty placeholder
                schema.rowColNames.forEach(colName => {
                    tr.appendChild(document.createElement('td'));
                });
                // Next, the column groups, which have a total value in the row
                for (let [realColName, value] of columnMap) {
                    try {
                        var col = totalsTable.findColumn(realColName);
                    } catch (e) {
                        // If the column is not found, just skip it (key table update arrived first)
                        continue;
                    }
                    var td = document.createElement('td');
                    td.textContent = row.get(col);
                    var format = row.getFormat(col);
                    td.style.backgroundColor = format.backgroundColor;
                    td.style.color = format.color;
                    td.style.weight = 'bold';
                    tr.appendChild(td);
                }
                // Last, append the cell with the total value of the whole table
                var totalsCol = totalsTable.findColumn('__TOTALS_COLUMN');
                var td = document.createElement('td');
                td.textContent = row.get(totalsCol);
                var format = row.getFormat(totalsCol);
                td.style.backgroundColor = format.backgroundColor;
                td.style.color = format.color;
                td.style.weight = 'bold';
                tr.appendChild(td);

                foot.appendChild(tr);
            });
        }

        // Subscribe to data - could be selective about columns to subscribe to:
        // Load the very first page - could implement paging here
        load();
        // Only one row in totals, subscribe to it
        totalsTable && totalsTable.setViewport(0, 0);
    }
    function load() {
        table.setViewport(currentOffset, currentOffset + PAGE_SIZE - 1);
    }
</script>
</body>
</html>
